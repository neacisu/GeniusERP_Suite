name: Auto-merge cu Label

# Trigger: CÃ¢nd un label este adÄƒugat la un PR
on:
  pull_request:
    types: [labeled]

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    name: Auto-merge PR cu label ready-for-staging
    runs-on: ubuntu-latest
    # RuleazÄƒ doar pentru label-ul specific
    if: github.event.label.name == 'ready-for-staging'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: VerificÄƒ branch-ul È›intÄƒ
        id: check-target
        run: |
          BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
          HEAD_BRANCH="${{ github.event.pull_request.head.ref }}"
          
          echo "base_branch=$BASE_BRANCH" >> $GITHUB_OUTPUT
          echo "head_branch=$HEAD_BRANCH" >> $GITHUB_OUTPUT
          
          # Auto-merge este permis DOAR pentru PR-uri dev â†’ staging
          if [ "$BASE_BRANCH" == "staging" ] && [ "$HEAD_BRANCH" == "dev" ]; then
            echo "âœ… Auto-merge permis pentru dev â†’ staging"
            echo "allowed=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ Auto-merge NU este permis pentru $HEAD_BRANCH â†’ $BASE_BRANCH"
            echo "Auto-merge este disponibil DOAR pentru PR-uri dev â†’ staging"
            echo "allowed=false" >> $GITHUB_OUTPUT
          fi

      - name: VerificÄƒ status CI
        id: check-ci
        if: steps.check-target.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            
            // ObÈ›ine toate check-urile pentru commit-ul de pe head
            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.head.sha,
            });
            
            // VerificÄƒ dacÄƒ toate check-urile au trecut
            const allPassed = checks.check_runs.every(check => 
              check.status === 'completed' && check.conclusion === 'success'
            );
            
            const totalChecks = checks.check_runs.length;
            const passedChecks = checks.check_runs.filter(c => c.conclusion === 'success').length;
            
            console.log(`âœ… ${passedChecks}/${totalChecks} verificÄƒri au trecut`);
            
            if (allPassed && totalChecks > 0) {
              core.setOutput('ci_passed', 'true');
              return true;
            } else {
              core.setOutput('ci_passed', 'false');
              
              // AdaugÄƒ un comentariu explicativ
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `âš ï¸ **Auto-merge nu poate continua**\n\n` +
                      `VerificÄƒrile CI nu au trecut toate:\n` +
                      `- âœ… Trecut: ${passedChecks}\n` +
                      `- âŒ EÈ™uat/Ãn aÈ™teptare: ${totalChecks - passedChecks}\n\n` +
                      `Te rog aÈ™teaptÄƒ ca toate verificÄƒrile sÄƒ treacÄƒ È™i apoi adaugÄƒ din nou label-ul \`ready-for-staging\`.`
              });
              
              return false;
            }

      - name: VerificÄƒ review-uri
        id: check-reviews
        if: steps.check-target.outputs.allowed == 'true' && steps.check-ci.outputs.ci_passed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            
            // ObÈ›ine toate review-urile
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
            });
            
            // GrupeazÄƒ review-urile per utilizator (ultimul review cont)
            const latestReviews = {};
            reviews.forEach(review => {
              if (!latestReviews[review.user.login] || 
                  new Date(review.submitted_at) > new Date(latestReviews[review.user.login].submitted_at)) {
                latestReviews[review.user.login] = review;
              }
            });
            
            // VerificÄƒ dacÄƒ existÄƒ cel puÈ›in o aprobare
            const approvals = Object.values(latestReviews).filter(r => r.state === 'APPROVED');
            const rejections = Object.values(latestReviews).filter(r => r.state === 'CHANGES_REQUESTED');
            
            console.log(`âœ… Aprobare: ${approvals.length}`);
            console.log(`âŒ ModificÄƒri cerute: ${rejections.length}`);
            
            // Pentru dev â†’ staging, este opÈ›ional sÄƒ ai review (mai relaxat)
            // Dar dacÄƒ existÄƒ review-uri, nu trebuie sÄƒ fie rejection
            if (rejections.length > 0) {
              core.setOutput('reviews_ok', 'false');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `âš ï¸ **Auto-merge nu poate continua**\n\n` +
                      `ExistÄƒ ${rejections.length} review-uri care cer modificÄƒri.\n\n` +
                      `Te rog rezolvÄƒ feedback-ul È™i apoi adaugÄƒ din nou label-ul \`ready-for-staging\`.`
              });
              
              return false;
            }
            
            core.setOutput('reviews_ok', 'true');
            return true;

      - name: Merge Pull Request
        if: |
          steps.check-target.outputs.allowed == 'true' && 
          steps.check-ci.outputs.ci_passed == 'true' && 
          steps.check-reviews.outputs.reviews_ok == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            
            try {
              // Merge PR-ul folosind merge commit (no-ff)
              const result = await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                merge_method: 'merge',  // FoloseÈ™te merge commit (no fast-forward)
                commit_title: `ğŸš€ Auto-merge: ${pr.title}`,
                commit_message: `Auto-merged PR #${pr.number} prin workflow automation.\n\n` +
                                `Label: ready-for-staging\n` +
                                `Merged by: github-actions[bot]`
              });
              
              console.log('âœ… PR merge-uit cu succes!');
              
              // AdaugÄƒ un comentariu de confirmare
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `âœ… **Auto-merge reuÈ™it!**\n\n` +
                      `PR-ul a fost merge-uit automat Ã®n \`${pr.base.ref}\`.\n\n` +
                      `UrmÄƒtorii paÈ™i:\n` +
                      `1. âœ… Deploy-ul pe staging va fi declanÈ™at automat\n` +
                      `2. ğŸ§ª TesteazÄƒ schimbÄƒrile Ã®n staging\n` +
                      `3. ğŸš€ CÃ¢nd eÈ™ti gata, creeazÄƒ PR staging â†’ master pentru production`
              });
              
              return result;
            } catch (error) {
              console.error('âŒ Eroare la merge:', error);
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `âŒ **Auto-merge eÈ™uat**\n\n` +
                      `A apÄƒrut o eroare la merge:\n\`\`\`\n${error.message}\n\`\`\`\n\n` +
                      `Te rog verificÄƒ conflictele sau merge-uieÈ™te manual PR-ul.`
              });
              
              throw error;
            }

      - name: Cleanup label (dacÄƒ merge eÈ™ueazÄƒ)
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            // EliminÄƒ label-ul pentru a putea fi re-adÄƒugat dupÄƒ rezolvarea problemei
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              name: 'ready-for-staging'
            });

      - name: Warning pentru branch-uri nesuportate
        if: steps.check-target.outputs.allowed == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: `âš ï¸ **Auto-merge nu este disponibil pentru acest PR**\n\n` +
                    `Label-ul \`ready-for-staging\` funcÈ›ioneazÄƒ DOAR pentru PR-uri **dev â†’ staging**.\n\n` +
                    `Acest PR este: **${pr.head.ref} â†’ ${pr.base.ref}**\n\n` +
                    `Pentru alte PR-uri (ex: staging â†’ master), merge-ul trebuie fÄƒcut **manual** dupÄƒ review.`
            });
            
            // EliminÄƒ label-ul pentru cÄƒ nu este valid pentru acest PR
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              name: 'ready-for-staging'
            });

